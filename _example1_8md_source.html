<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CombineHarvester: docs/Example1.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 70px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CombineHarvester
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_example1_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">docs/Example1.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_example1_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Examples Part I {#intro1}</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;=========================</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;[TOC]</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;**File**: CombineTools/bin/Example1.cpp</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;In this example we use CombineHarvester to parse an existing datacard and then extract information from it. Open the file above and take a look at the source code. To run the example, first make sure the code has been compiled with `scram`:</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    cd $CMSSW_BASE/src</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    scram b -j4</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    Example1</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;Parsing a single card {#ex1-p1}</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;===============================</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;In the first part we locate and open a single text datacard file:</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;\snippet CombineTools/bin/Example1.cpp part1</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;When parsing a datacard, CombineHarvester breaks down the information it contains into sets of objects, each represented by a C++ class. A ch::Observation object stores the information about the observed data in a single category, and likewise ch::Process stores the information for one expected signal or background process in a category. A ch::Systematic object records the uncertainty value assigned to a particular process from a particular source.</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;\note Internally a CombineHarvester contains three vectors, one for each kind of object. It&#39;s the job of the [ParseDatacard](\ref ch::CombineHarvester::ParseDatacard) method to build a new set of these objects, extract the mapped histograms, and append them to these vectors. The histogram extraction is done automatically using the mapping rules given in the datacard (the lines starting with `shape`). Once the mapped ROOT file has been located and opened, the relevant histograms are copied into their corresponding CombineHarvester objects.</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;Each object class stores a standard set of metadata, designed to aid in the filtering and selection of particular objects within a CombineHarvester, and which in the example above is specified explicitly. The possible metadata is listed in the following table.</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160; | name         | type       | example value |</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; | :----------: | :--------: | :----------:  |</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; | bin          | string     | *automatic*   |</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; | process      | string     | *automatic*   |</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160; | analysis     | string     | &quot;htt&quot;         |</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; | era          | string     | &quot;8TeV&quot;        |</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160; | channel      | string     | &quot;mt&quot;          |</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; | bin_id       | int        | 6             |</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160; | mass         | string     | &quot;125&quot;         |</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; Of these only `bin`, `process` and `mass` are tracked and used by combine, the others are optional and can be left empty if unneeded. The `bin` property is used to uniquely label an event category. Along with the process names, this is written directly into the datacard and is extracted automatically. The `mass` property is an exception: although we typically create a datacard for a particular signal mass hypothesis this information is not recorded in the datacard, but rather is passed to combine as a command line option, e.g. `combine -M Asymptotic -m 125 my_datacard.txt`.</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160; \warning If `mass` is not specified, [ParseDatacard](\ref ch::CombineHarvester::ParseDatacard) is likely to fail as this property is often needed to map signal processes to histograms in the input ROOT file. You can tell if this property is needed by looking for the term `$MASS` in the `shapes` rules at the top of the text datacard.</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;An important concept is that the objects created from a datacard are not explicitly linked - each is completely independent. When it&#39;s necessary to determine which objects are related, e.g. if we ask for the total uncertainty on a particular  process, CombineHarvester will determine this on-the-fly by matching up ch::Process and ch::Systematic objects that have identical metadata.</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;The last line of the code will print the information stored about the Observation, Process and Systematic entries that we&#39;ve created. Like many CombineHarvester methods, these Print functions return a reference to the calling object, meaning they can be chained together to keep the code concise. The output will look like:</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;\verbinclude CombineTools/input/examples/example1_1.txt</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;Parsing multiple cards {#ex1-p2}</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;================================</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;Next we create another CombineHarvester instance and parse several datacards, this time using a method in which the object metadata is inferred from the datacard filenames:</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;\snippet CombineTools/bin/Example1.cpp part2</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;In this ParseDatacard method only two arguments are required: the path to the text datacard and a string containing place-holders for the metadata. Note that there&#39;s no obligation to include all five place-holders in this string. Additionally, the place-holders are not restricted to appearing in the filename but may also be included in the preceding directory path, e.g. `$MASS/$ANALYSIS_$CHANNEL_$BINID_$ERA.txt` is also valid.</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;Filtering {#ex1-p3}</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;===================</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;Now let&#39;s pretend we are no longer interested in the first four categories we parsed. To remove objects we use a filter method. There are four generic filter methods: FilterAll, FilterObs, FilterProcs and FilterSysts that each accept a function, or function-type object that must have a single ch::Object, ch::Observation, ch::Process or ch::Systematic pointer argument and return a bool. A `true` return value indicates that the object should be dropped. The FilterAll method will act on all three object collections whereas the others operate only on their respective collections. It&#39;s often convenient to write a small lambda function in-place:</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;\snippet CombineTools/bin/Example1.cpp part3a</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;Alternatively,there are a number of fixed-property filters, in which you need only supply a vector of the object properties you want to keep:</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;\snippet CombineTools/bin/Example1.cpp part3b</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;An optional boolean can be supplied as a second argument. When set to false this reverses the logic -  objects with a property in the list will be dropped. In the second line we use this to remove all information about the QCD process. The full list of filter methods is found [here](\ref CH-Filters)</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;Yields, copying and sets {#ex1-p4}</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;==================================</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;In the final part of this example we take a look at the rate evaluation methods. These calculate the total event yields for either the observed data or the expected processes:</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;\snippet CombineTools/bin/Example1.cpp part4</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;Note that these functions are greedy - they will sum the contribution from every available Observation or Process entry. This means in the first line we get the total number of observed events in the three remaining categories. To get the yield for a single category we can prefix the function with a filter method. But here we must be careful, because we don&#39;t want to actually remove the information on the other categories permanently, which is what would happen if we just do:</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    cmb2.bin({&quot;muTau_vbf_loose&quot;}).GetObservedRate();</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    // cmb2 only contains objects for the &quot;muTau_vbf_loose&quot; category now!</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;To get around this we first call the [cp](\ref ch::CombineHarvester::cp) method on our CombineHarvester instance. This makes a shallow copy of the instance - in this it is only pointers to the contained objects, not the objects themselves, which are copied into a new instance. Such a copy is computationally fast to make, and we are free to filter objects from it without affecting the original instance at all.</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;\note Although filtering the objects in a shallow copy has no effect on the object lists in the original instance, both instances do still point to the same objects, so modifying the actual contents via the shallow copy will affect both instances. To create a full CombineHarvester copy, in which the underlying objects are also duplicated, use the [deep](\ref ch::CombineHarvester::deep) copy method instead.</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;The last part of the example code uses the CombineHarvester set-generating methods to conveniently loop through all defined (bin, process) combinations and print out the expected yield. The full list of available set-generating methods can be found [here](\ref CH-Set-Producers).</div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
</body>
</html>
